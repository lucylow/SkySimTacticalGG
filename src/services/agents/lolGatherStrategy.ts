import { BaseAgentImpl } from './baseAgent';
import { AgentInput, AgentTool, AgentInsight } from '@/types/agents';
import { 
  StrategyOutput, 
  FullGameState, 
  Layer1Static, 
  Layer2Dynamic, 
  Layer3Feedback 
} from '@/types/lolStrategy';
import { LolStrategyEngine } from '../LolStrategyEngine';

/**
 * LoLGatherStrategyAgent
 * 
 * Implements the GATHER -> STRATEGY -> WIN loop for League of Legends.
 * Uses a 3-layer information gathering system to generate winning strategies.
 */
export class LoLGatherStrategyAgent extends BaseAgentImpl {
  name = 'LoL GATHER Strategy Agent';
  role = 'macro_strategy_analyst' as any;
  description = 'Advanced LoL strategic engine using the 3-layer information gathering system.';
  
  private strategyEngine = new LolStrategyEngine();

  async execute(input: AgentInput): Promise<StrategyOutput> {
    // 1. GATHER Information Layers
    const gameState = await this.gatherInformationLayers(input);
    
    // 2. INTERPRET & DECIDE via Strategy Engine
    const strategy = this.strategyEngine.generateStrategy(gameState);
    
    // 3. ENRICH with base agent output properties
    return {
      ...strategy,
      agent_name: this.name,
      agent_role: this.role,
      // insights and recommendations are already generated by strategyEngine.generateStrategy
    };
  }

  /**
   * GATHER Information Layers
   * Translates raw AgentInput into the 3-layer architecture
   */
  private async gatherInformationLayers(input: AgentInput): Promise<FullGameState> {
    const { match_context, opponent_data, round_data } = input;
    
    // Layer 1: Static / Pre-game
    const layer1: Layer1Static = {
      myChamp: (match_context as any)?.myChamp || 'Unknown',
      enemyChamp: (match_context as any)?.enemyChamp || 'Unknown',
      teamComp: (match_context as any)?.teamComp || 'front2back',
      enemyComp: (match_context as any)?.enemyComp || 'engage',
      playerTendencies: (opponent_data as any)?.playerTendencies || {},
      patchMeta: {
        earlyPressure: 0.2,
        scalingValue: 0.1,
      },
      role: (match_context as any)?.role || 'MIDDLE'
    };

    // Layer 2: Dynamic / In-game
    const layer2: Layer2Dynamic = {
      matchTime: (round_data as any)?.matchTime || 0,
      lanePriority: (round_data as any)?.lanePriority || { top: 0, mid: 0, bot: 0 },
      junglePathing: (round_data as any)?.junglePathing || [],
      visionScore: (round_data as any)?.visionScore || 0,
      objectiveTimers: (round_data as any)?.objectiveTimers || { dragon: 300, baron: 1200 },
      goldDiff: (round_data as any)?.goldDiff || 0,
      itemSpikes: (round_data as any)?.itemSpikes || []
    };

    // Layer 3: Feedback / Outcome
    const layer3: Layer3Feedback = {
      lastFightResult: (round_data as any)?.lastFightResult || 'EVEN',
      objectivesGained: (round_data as any)?.objectivesGained || [],
      deaths: (round_data as any)?.deaths || [],
      adaptationSignals: (round_data as any)?.adaptationSignals || []
    };

    return { layer1, layer2, layer3 };
  }

  getTools(): AgentTool[] {
    return [
      {
        name: 'recalculate_strategy',
        description: 'Recalculates the strategy based on updated live telemetry',
        parameters: {
          type: 'object',
          properties: {
            matchId: { type: 'string' }
          }
        },
        execute: async (args) => {
          return { status: 'success', message: 'Strategy updated for ' + args.matchId };
        }
      }
    ];
  }
}
